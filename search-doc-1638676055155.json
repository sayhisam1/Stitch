[{"title":"SystemDefinition","type":0,"sectionRef":"#","url":"api/SystemDefinition","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#properties","content":" "},{"title":"name​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#name","content":"&lt;/&gt; SystemDefinition.name: string? Used to identify the System in the World (should be unique). If name is not defined and the SystemDefinition is returned by a ModuleScript, then registering the ModuleScript will use the name of the ModuleScript.  "},{"title":"priority​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#priority","content":"&lt;/&gt; SystemDefinition.priority: number? Used to identify the System's priority within an updateEvent. Lower priority values run first. By default, the priority is 1000.  "},{"title":"updateEvent​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#updateEvent","content":"&lt;/&gt; SystemDefinition.updateEvent: RBXScriptSignal?  The event that the System should listen to for updates. Each time the event fires, the System is updated. By default, the event is RunService.Heartbeat. "},{"title":"Functions​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#functions","content":" "},{"title":"onCreate​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#onCreate","content":"&lt;/&gt; SystemDefinition:onCreate( world: World-- The World the System was added to. ) → nil Called when the System is added to a World. You should override this function if you wanted to do some manual setup for the System.  "},{"title":"onUpdate​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#onUpdate","content":"&lt;/&gt; SystemDefinition:onUpdate( world: World,-- The World the System belongs to. ...: any-- The arguments passed to the updateEvent. By default, this is just the time since last update. ) → nil Called when the System is updated. You should override this function to control what happens on each update.  "},{"title":"onDestroy​","type":1,"pageTitle":"SystemDefinition","url":"api/SystemDefinition#onDestroy","content":"&lt;/&gt; SystemDefinition:onDestroy( world: World-- The World the System belonged to. ) → nil Called when the System is removed from the World. You should override this function if you wanted to do some manual cleanup for the System. "},{"title":"ComponentDefinition","type":0,"sectionRef":"#","url":"api/ComponentDefinition","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#properties","content":" "},{"title":"name​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#name","content":"&lt;/&gt; ComponentDefinition.name: string? Used to identify the Component in the World (should be unique). If name is not defined and the ComponentDefinition is returned by a ModuleScript, then registering the ModuleScript will use the name of the ModuleScript.  "},{"title":"defaults​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#defaults","content":"&lt;/&gt; ComponentDefinition.defaults: {}? The default data to use when adding a component. If data is provided to World.addComponent, then the data will be merged with the defaults.  "},{"title":"validator​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#validator","content":"&lt;/&gt; ComponentDefinition.validator: ((data: {}) → boolean)? A function that will be called to validate the data when adding or changing a component. Should return true if the data is valid, false otherwise.  "},{"title":"tag​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#tag","content":"special &lt;/&gt; ComponentDefinition.tag: boolean? | string?  info This property only has an effect when TagSystem is added to the World. Used to apply CollectionService tags to the entity the component is attached to (see: TagSystem for more details). If tag is true, the tag will be the same as the name of the ComponentDefinition.  "},{"title":"replicate​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#replicate","content":"special &lt;/&gt; ComponentDefinition.replicate: boolean?  info This property only has an effect when ReplicationSystem is added to the World. Enables replication of the component (see: ReplicationSystem for more details).  "},{"title":"destructor​","type":1,"pageTitle":"ComponentDefinition","url":"api/ComponentDefinition#destructor","content":"&lt;/&gt; ComponentDefinition.destructor: ( entity, data ) → nil? If set, this function will be called when the component is removed. You should use this to clean up any resources that were allocated when adding the component (e.g. any event connections). The function will be passed the entity and the data of the component. danger Component destructors should not yield - this will lead to undefined behavior! "},{"title":"FAQ","type":0,"sectionRef":"#","url":"docs/FAQ","content":"","keywords":""},{"title":"What is Stitch?​","type":1,"pageTitle":"FAQ","url":"docs/FAQ#what-is-stitch","content":"Stitch is a simple and powerful Entity Component System (ECS) built specifically for Roblox game development. Stitch allows you to separate the data and behavior of things in your game. This means your code will be easier to understand and update, and more performant. "},{"title":"Why should I use an ECS over Object-Oriented Programming (OOP)?​","type":1,"pageTitle":"FAQ","url":"docs/FAQ#why-should-i-use-an-ecs-over-object-oriented-programming-oop","content":"Using an ECS can save you from complex code that arises due to the diamond inheritance problem in large object-oriented games. Using OOP, you will likely run into scenarios where the diamond problem is impossible to avoid without structuring your entire game. ECS solves this issue by removing inheritance altogether - instead, you compose many different components on a single entity. This makes it easy to grow your codebase and rapidly add new features. However, ECS and OOP aren't mutually exclusive - you can (and should!) use a mix of both when it's easier. "},{"title":"I have a question not on this page!​","type":1,"pageTitle":"FAQ","url":"docs/FAQ#i-have-a-question-not-on-this-page","content":"Awesome! Feel free to message me on Discord (sayhisam1#7705), or make an issue on the repository with your question. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/GettingStarted","content":"Getting Started What is Stitch? Stitch is a simple and powerful Entity Component System (ECS) built specifically for Roblox game development. Stitch allows you to separate the data and behavior of things in your game. This means your code will be easier to understand and update, and more performant. Installation Follow the installation guide to install Stitch. Basic Usage The basic pattern behind Stitch is to create a single script on the server and a single script on the client. Both scripts will do the same thing - create a new World and register some Systems and Components to it. Here's what the simplest example of creating a world would look like: -- Change this if you installed Stitch to a different folder local Stitch = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Stitch) local world = Stitch.World.new() Copy We would need to have this code on both the server and client. Entities An entity is anything in your game. It could be a part, a NPC, or a weapon. Entities can have multiple Components attached to them. Stitch automatically treats Roblox instances as entities, so you don't have to do anything special to use them. Registering a new Component A Component is a way to store data for one aspect of an entity. For example, a Zombie npc in your game may have a Health component, as well as a Damage component. In Stitch, components should only be used for data. Before they can be used, Components must be registered. Here's how to register a simple Component to the world: local Stitch = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Stitch) local world = Stitch.World.new() -- Registers a simple component called &quot;velocity&quot; to the world world:registerComponent({ name = &quot;velocity&quot; }) Copy Now that we have registered a component, we can now attach it to instances. Let's say you had a part named Arrow in Workspace. We can use the velocity component like this: -- Add a velocity component to Arrow: world:addComponent(&quot;velocity&quot;, Workspace.Arrow, { value = Vector3.new(0, 0, 0) }) -- Get the velocity component from Arrow: arrowVelocity = world:getComponent(&quot;velocity&quot;, Workspace.Arrow) print(arrowVelocity.value) -- prints Vector3.new(0, 0, 0) -- Set the data of the component to something else: world:setComponent(&quot;velocity&quot;, Workspace.Arrow, { value = Vector3.new(1, 0, 0) }) Copy Adding a System We can now associate behavior with the velocity component using a System. A System is a way to associate behavior to one or many components. A key idea of the ECS pattern is that Systems should not store any state themselves; Data should only be store on Components, and behavior should be handled by Systems. We previously defined a velocity component, and attached it to an Arrow. Let's now define a system that moves anything with the velocity component: -- add a new system to the world that moves all instances with a velocity component world:addSystem({ name = &quot;VelocitySystem&quot;, onUpdate = function(world, dt) -- onUpdate is passed the world and time since last update -- query to iterate through all entities with a velocity component world:createQuery():all(&quot;velocity&quot;):forEach(function(instance, velocityData) instance.Position = instance.Position + velocityData.value * dt end) end }) Copy If you run the game now, you should see that anything with a velocity component is moving. ❗ To take full advantage of everything Stitch can do, it is recommended you keep each System and Component in a different ModuleScript. When adding systems or registering components, the methods can directly take a ModuleScript, which is required for HotReloading functionality. Please take a look at a more advanced example to see how this would look in practice.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method 1 (recommended) - Using Wally and Rojo​","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1-recommended---using-wally-and-rojo","content":"Add Stitch = &quot;sayhisam1/stitch@0.12.0&quot; under the [dependencies] section in wally.tomlUse wally install to automatically download StitchUpdate your Rojo configuration to point to the appropriate path and sync the file in. "},{"title":"Method 2 - Manual​","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---manual","content":"Visit the latest release pageUnder Assets, click Stitch.rbxm to download it Using Rojo? Put Stitch.rbxm in your game source directly.Using Roblox Studio? In the Explorer, navigate to where you wish to insert Stitch into (typically under ReplicatedStorage). Right-click and select Insert from file in menu. "},{"title":"Method 3 - Git Submodule​","type":1,"pageTitle":"Installation","url":"docs/Installation#method-3---git-submodule","content":"Add the Stitch repository as a git submodule (ideally within a folder called submodules) (tutorial here)Update your Rojo configuration to point to the appropriate path and sync the file in. "},{"title":"World","type":0,"sectionRef":"#","url":"api/World","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"World","url":"api/World#types","content":" "},{"title":"ComponentResolvable​","type":1,"pageTitle":"World","url":"api/World#ComponentResolvable","content":"&lt;/&gt; type ComponentResolvable = {} | string Used to resolve a component type in World apis. Anywhere you see a ComponentResolvable, you can either pass the ComponentDefinition table used while registering the component, or a string that is the name of the component. "},{"title":"Properties​","type":1,"pageTitle":"World","url":"api/World#properties","content":" "},{"title":"NONE​","type":1,"pageTitle":"World","url":"api/World#NONE","content":"&lt;/&gt; World.NONE: UserData Used to set keys to nil on world:addComponent or world:updateComponent calls. world:updateComponent(&quot;someComponent&quot;, entity, { foo = World.NONE }) world:getComponent(&quot;someComponent&quot;, entity).foo -- is nil  "},{"title":"Functions​","type":1,"pageTitle":"World","url":"api/World#functions","content":" "},{"title":"new​","type":1,"pageTitle":"World","url":"api/World#new","content":"constructor &lt;/&gt; World.new( namespace: string?-- The namespace to use for this world. ) → World Creates a new World.  "},{"title":"destroy​","type":1,"pageTitle":"World","url":"api/World#destroy","content":"destructor &lt;/&gt; World:destroy() → nil Destroys a World. Components are detached from entities and Systems are stopped.  "},{"title":"registerComponent​","type":1,"pageTitle":"World","url":"api/World#registerComponent","content":"&lt;/&gt; World:registerComponent(componentDefinition: ComponentDefinition | ModuleScript ) → nil Registers a new ComponentDefintion to the World. When passed as a ModuleScript: Hot reloading will be enabled The ComponentDefinition will use the name of the ModuleScript if not provided.  "},{"title":"unregisterComponent​","type":1,"pageTitle":"World","url":"api/World#unregisterComponent","content":"&lt;/&gt; World:unregisterComponent(componentResolvable: ComponentResolvable) → nil Unregisters a ComponentDefinition from the World.  "},{"title":"createQuery​","type":1,"pageTitle":"World","url":"api/World#createQuery","content":"&lt;/&gt; World:createQuery() → EntityQuery Creates a new EntityQuery.  "},{"title":"addSystem​","type":1,"pageTitle":"World","url":"api/World#addSystem","content":"&lt;/&gt; World:addSystem(systemDefinition: SystemDefinition | ModuleScript ) → nil Adds a new System to the World. When passed as a ModuleScript: Hot reloading will be enabled The SystemDefinition will use the name of the ModuleScript if not provided.  "},{"title":"removeSystem​","type":1,"pageTitle":"World","url":"api/World#removeSystem","content":"&lt;/&gt; World:removeSystem(systemResolvable: SystemDefinition | ModuleScript ) → nil Removes a System from the World.  "},{"title":"addComponent​","type":1,"pageTitle":"World","url":"api/World#addComponent","content":"&lt;/&gt; World:addComponent( componentResolvable: ComponentResolvable,-- the type of component to attach entity: Instance | {},-- the entity to attach the component to data: {}?-- the data to use for the component ) → {}-- The added component Attaches a component to an entity with given data. If no data is provided, the .default property of the ComponentDefinition will be used. "},{"title":"Errors","type":1,"pageTitle":"World","url":"api/World##","content":"Type\tDescription&quot;Already exists&quot;\tThrown if the given component already exists on the entity.  "},{"title":"getComponent​","type":1,"pageTitle":"World","url":"api/World#getComponent","content":"&lt;/&gt; World:getComponent( componentResolvable: ComponentResolvable,-- the type of component to attach entity: Instance | {}-- the entity to get component from ) → {}?-- The attached component Gets the component of the given type attached to the given entity. Returns nil if no such component is attached.  "},{"title":"getEntitiesWith​","type":1,"pageTitle":"World","url":"api/World#getEntitiesWith","content":"&lt;/&gt; World:getEntitiesWith( componentResolvable: ComponentResolvable-- the type of component to get entities with ) → {any}-- all entities in the world with the given component Gets all entities with the given component type.  "},{"title":"setComponent​","type":1,"pageTitle":"World","url":"api/World#setComponent","content":"&lt;/&gt; World:setComponent( componentResolvable: ComponentResolvable,-- the type of component entity: Instance | {},-- the entity with the component data: {}-- the data to set ) → {}-- The newly set component Sets the data of the given component on the given entity.  "},{"title":"updateComponent​","type":1,"pageTitle":"World","url":"api/World#updateComponent","content":"&lt;/&gt; World:updateComponent( componentResolvable: ComponentResolvable,-- the type of component entity: Instance | {},-- the entity with the component data: {}-- the data to merge into the existing data ) → {}-- The newly updated component Updates (i.e. merges the keys) the data of the given component on the given entity.  "},{"title":"removeComponent​","type":1,"pageTitle":"World","url":"api/World#removeComponent","content":"&lt;/&gt; World:removeComponent( componentResolvable: ComponentResolvable,-- the type of component entity: Instance | {}-- the entity with the component ) → nil Removes the given component from the given entity.  "},{"title":"getComponentAddedSignal​","type":1,"pageTitle":"World","url":"api/World#getComponentAddedSignal","content":"signal &lt;/&gt; World:getComponentAddedSignal( entity: Instance | {}-- the entity to listen for ) → Signal-- The Signal Returns a Signal that fires with parameters (componentName, data) whenever a component is added to the specified entity.  "},{"title":"getComponentChangedSignal​","type":1,"pageTitle":"World","url":"api/World#getComponentChangedSignal","content":"signal &lt;/&gt; World:getComponentChangedSignal( entity: Instance | {}-- the entity to listen for ) → Signal-- The Signal Returns a Signal that fires with parameters (componentName, data, previousData) whenever a component is changed (i.e. updated or set) on the specified entity.  "},{"title":"getComponentRemovingSignal​","type":1,"pageTitle":"World","url":"api/World#getComponentRemovingSignal","content":"signal &lt;/&gt; World:getComponentRemovingSignal( entity: Instance | {}-- the entity to listen for ) → Signal-- The Signal Returns a Signal that fires with parameters (componentName, data) whenever a component is about to be removed from the specified entity.  "},{"title":"getEntityAddedSignal​","type":1,"pageTitle":"World","url":"api/World#getEntityAddedSignal","content":"signal &lt;/&gt; World:getEntityAddedSignal( componentResolvable: ComponentResolvable-- the type of component to listen for ) → Signal-- The Signal Returns a Signal that fires with parameters (entity, data) whenever the specified component is added to an entity.  "},{"title":"getEntityChangedSignal​","type":1,"pageTitle":"World","url":"api/World#getEntityChangedSignal","content":"signal &lt;/&gt; World:getEntityChangedSignal( componentResolvable: ComponentResolvable-- the type of component to listen for ) → Signal-- The Signal Returns a Signal that fires with parameters (entity, data, previousData) whenever an entity has a change (i.e. updated or set) on the specified component's data.  "},{"title":"getEntityRemovingSignal​","type":1,"pageTitle":"World","url":"api/World#getEntityRemovingSignal","content":"signal &lt;/&gt; World:getEntityRemovingSignal( componentResolvable: ComponentResolvable-- the type of component to listen for ) → Signal-- The Signal Returns a Signal that fires with parameters (entity, data) whenever the specified component is about to be removed from an entity. "},{"title":"Quick links","type":0,"sectionRef":"#","url":"docs/intro","content":"Quick links Installing StitchGetting StartedAPI Docs","keywords":""}]